# Event Storming

* It is a workshop
* To clarify the Domain of the Application.
* How to model the Application
* We are talking about big applications
* One person to conduct the workshop
* Explore to consolidate everything
* Dynamic and clarifying to everyone
* Resolve complexity business
* People usually use "PostIt".
* Goal: Understand and Map what happens in the System, through the events
* With it, the understanding of the project gets much more clear (to developers, to the Domain Experts, etc). With it, everyone can communicate with the ubiquitous language (universal language)

## Cards

- First, List the Actors (Domain Experts). Then, list the Events and then list all the Commands. Then, put the PostIts in this order:
  * Actor -> Command -> Event (Exemple: Video Administrator (Yellow) -> do Video Upload (Blue) -> Upload Done (Orange)

## Main Cards

- Event: Domain Event: An Event (everything that happened in the past) (a result of an action) that is processed by the system and makes sense to be exposed in Event Storming) generated by the system. So, you have to list it. (Suggestion: An Orange PostIt.
- Command: Someone (Domain Expert: Yellow "PostIt") "does the command" (Blue "PostIt") (Can be a user, an administrator, buyer, etc.). Every event is generated by a command. Ex: Finish a Purchase (Command) -> Purchase Done (Event). With commands, you can understand the operations that your system does.

## Other Cards

- Decision made: A Green PostIt that can be putted to make a decision
- Policy: A Purple PostIt. Something that happens through a trigger (Ex: When I create a video, send an email, so, it can be automatically or by a final user). "When I do something, does anything happen?" Use policy in this case.

![](https://github.com/fabiolnh/event-storming/blob/main/assets/pic1.png?raw=true)

## Chronological
- The events need to be put in order (Can be parallel and can be through business areas)

## Event Origin
- Can be:
  * An Action based in the Client (A command executed by the client)
  * An External System
  * A Scheduler (time)
  * A Policy (a consequence of another event)

## Aggregator
- Is where we have the business rules 
- It is a set of entities and valued objects that have business rules and validation to guarantee consistency in the business. 
- Between a Command and an Domain Event you will always have an Aggregator
- In the Aggregator, we have the business rules.
- Every command talks with an Agregator, and this aggregator is responsible for generating the event.

## Delimited Contexts
- There are some events that are the "Key" to go to another area of the system. Ex: When a signature is approved, the client is ready to watch a video. (but watch a video is in another zone). So, this way we have to put a barrier between these areas, and it symbolizes the principal event (ex: approved signature). This is an Pivot Event. (In DDD: Bounded Contexts)
- OBS: When we have different systems connected listening the same domain event, there is a big chance that they are different contexts
- It is hard to define context. It needs to be discussed. In the end, it is good because you do not have to rewrite code. It can save time for everyone.
- With it, we can think in: Attention Points, Divergency Points and Opportunity Points.

 ![](https://github.com/fabiolnh/event-storming/blob/main/assets/pic2.png?raw=true)

## Arrow Voting
- Blue arrows pointing to the HotSpot (a PostIt when there is something that is not everyone that agrees)
- For cornel cases. When there is a conflict of ideas between the people (ex: the domain experts) that are discussing. It is a vote. Carefully, to not break the climate between the team. 

## Contexts and Microservices
- With defined contexts, you can see what are all the microservices that you need to implement. However, it depends on the size of the granularity you want. Defined contexts are the initial step to start to visualize the microservices.

## Good to draw:
- https://whimsical.com/
- Example from Full Cycle: https://whimsical.com/event-storming-LR9ex19rzbFaq4o2yEo9DQ
